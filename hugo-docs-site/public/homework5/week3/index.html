<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title></title>
    <link rel="stylesheet" href="/css/custom.css">
</head>
<body>
    <header>
        <h1>NKU 640 Documentation</h1>
        <nav>
            <ul>
                
                    <li><a href="/">Home</a></li>
                
                    <li><a href="/homework3/">Homework 3</a></li>
                
                    <li><a href="/homework4/">Homework 4</a></li>
                
                    <li><a href="/homework5/">Homework 5</a></li>
                
            </ul>
        </nav>
    </header>
    <main>
        <h1></h1>
<h2 id="python-for-software-engineering">Python for Software Engineering</h2>
<ul>
<li><strong>Python</strong> – an interpreted, high-level, general-purpose programming language known for its readable syntax. Python&rsquo;s design philosophy emphasizes code clarity and a simple syntax that helps developers write clear, logical code.</li>
<li>Python supports multiple paradigms (procedural, object-oriented, functional). In this course we use Python to illustrate object-oriented programming (OOP) concepts because of its simplicity and widespread use.</li>
<li>Key Python features include dynamic typing (you don&rsquo;t declare variable types), a rich standard library, and cross-platform portability. This allows rapid prototyping and experimentation while learning design principles.</li>
</ul>
<hr>
<h2 id="object-oriented-programming-basics">Object-Oriented Programming Basics</h2>
<ul>
<li><strong>Object-Oriented Programming (OOP)</strong> is a paradigm centered on <em>objects</em> (instances of classes) that encapsulate data and behavior. OOP promotes organizing software as a collection of interacting objects.</li>
<li><strong>Four Pillars of OOP:</strong>
<ul>
<li><em>Abstraction</em> – modeling real-world entities by focusing on relevant features while ignoring unnecessary details.</li>
<li><em>Encapsulation</em> – hiding internal state and implementation details of an object behind a public interface.</li>
<li><em>Inheritance</em> – creating new classes by extending existing ones, enabling reuse of code and establishing hierarchies.</li>
<li><em>Polymorphism</em> – treating objects of different subclasses through a common interface, and automatically calling the correct overridden behaviors at runtime.</li>
</ul>
</li>
<li>These principles improve code <strong>modularity</strong> and <strong>maintainability</strong>. For example, abstraction and encapsulation manage complexity, and inheritance with polymorphism promotes code reuse and flexibility.</li>
</ul>
<hr>
<h2 id="abstraction--inheritance-in-practice">Abstraction &amp; Inheritance in Practice</h2>
<p><strong>Abstraction Example:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">User</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__init__</span>(self, name, email):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>name <span style="color:#f92672">=</span> name
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>email <span style="color:#f92672">=</span> email
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">send_notification</span>(self):
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Abstract the complex email sending logic</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">pass</span>
</span></span></code></pre></div><p><strong>Inheritance Example:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Employee</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__init__</span>(self, name, salary):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>name <span style="color:#f92672">=</span> name
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>salary <span style="color:#f92672">=</span> salary
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Manager</span>(Employee):  <span style="color:#75715e"># Inherits from Employee</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__init__</span>(self, name, salary, department):
</span></span><span style="display:flex;"><span>        super()<span style="color:#f92672">.</span><span style="color:#a6e22e">__init__</span>(name, salary)
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>department <span style="color:#f92672">=</span> department
</span></span></code></pre></div><hr>
<h2 id="abstraction--inheritance-concepts">Abstraction &amp; Inheritance Concepts</h2>
<ul>
<li><strong>Abstraction:</strong> In design, identify the essential attributes of an entity and model a class for it, omitting extraneous details. For instance, a &ldquo;User&rdquo; class might abstract common user properties (name, email) relevant to the system, leaving out personal details not needed. Abstraction allows focusing on <em>what</em> an object does instead of <em>how</em> it does it.</li>
<li><strong>Inheritance:</strong> Establishes an &ldquo;is-a&rdquo; relationship between classes. A base (parent) class defines general attributes and methods, and a derived (child) class inherits those and extends or overrides behavior. Inheritance promotes code reuse – new classes reuse existing code instead of writing from scratch.</li>
<li>Using inheritance wisely can reduce duplication, but be cautious: subclasses should truly satisfy the relationship (Liskov Substitution Principle). If a subclass violates expectations of the parent class, the design can break. Prefer composition over inheritance when appropriate to avoid rigid hierarchies.</li>
</ul>
<hr>
<h2 id="uml-diagrams-for-design">UML Diagrams for Design</h2>
<ul>
<li><strong>Unified Modeling Language (UML)</strong> provides a standard way to visualize system design. UML diagrams are blueprints for understanding software structure and behavior without diving into code.</li>
<li><strong>Structure Diagrams:</strong> e.g. <em>Class Diagrams</em> show classes, their attributes and methods, and relationships (associations, inheritance, composition). This helps in designing the static architecture of the system.</li>
<li><strong>Behavior Diagrams:</strong> e.g. <em>Sequence Diagrams</em> illustrate interactions over time between objects (method call flows), and <em>State Diagrams</em> show state transitions of an object. <em>Use Case Diagrams</em> (covered next week) depict the functional requirements by showing actors and their interactions with the system.</li>
<li>By using UML, we can communicate designs clearly. For instance, a class diagram can clarify how classes relate (a <strong>composition</strong> is depicted with a filled diamond, meaning a strong &ldquo;has-a&rdquo; relationship). UML is a common language for developers to collaborate on design before coding.</li>
</ul>
<hr>
<h2 id="software-requirements-fundamentals">Software Requirements Fundamentals</h2>
<ul>
<li><strong>Requirements</strong> capture what the software should <em>do</em> (functional requirements) and how it should <em>be</em> (non-functional requirements). A functional requirement might be &ldquo;the system shall <strong>send a password reset email</strong> to the user upon request,&rdquo; whereas a non-functional requirement could be &ldquo;the email is sent <strong>within 5 seconds</strong> of request (performance)&rdquo;.</li>
<li><em>Functional vs Non-Functional:</em> Broadly, functional requirements define <strong>what</strong> a system must accomplish (features and behaviors), and non-functional requirements define <strong>how</strong> the system performs or the constraints on it (quality attributes like reliability, usability, security). For example, functional requirements are expressed as specific actions or outputs (&ldquo;system shall do X&rdquo;), while non-functional are expressed as properties or criteria (&ldquo;system shall be Y&rdquo; in terms of speed, security, etc.).</li>
<li>Gathering clear requirements is critical to project success. Techniques include stakeholder interviews, user stories, and use cases. A well-written requirement is unambiguous and testable. These requirements form the foundation for design and testing – if they are wrong or incomplete, the software will not meet user needs.</li>
</ul>
<hr>

    </main>
    <footer>
        <p>&copy; 2025 NKU 640 Documentation</p>
    </footer>
</body>
</html>